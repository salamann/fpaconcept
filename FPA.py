#!/usr/bin/env python
# -*- coding: utf-8 -*-

import numpy as np
import pylab as pl
from scipy.linalg import solve

# twisted -- event based networking module
# a = solve(b, c)
# solves [b][a][c] matrix for [a]

# Reads csv file
# All numerical data will be converted to float, otherwise string
#
# filename - filepath and filename
#
def readcsv(filename):
    import csv
    data = []
    csvfile = file(filename)
    reader = csv.reader(csvfile)
    for row in reader:
        tmp = []
        for col in row:
            try:
                tmp.append(float(col))
            except:
                tmp.append(col)
        data.append(tmp)
    return data

#open any files to lists
def open2read(filename):
    data1 = open(filename)
    lines = data1.readlines()
    data1.close()
    return lines

#read a aerodynamics data generated by xlfr5
def readdata(filename):
    #Xfoil data: 12, XFLR5 data: 11
    start_row = 11
    data = open2read(filename)
    data = [i.rsplit() for i in data [start_row:]]
    data = np.array(data,dtype=float)
    return data

def pltfigure(x,y,nn,nlabel):
    pl.subplot(410 + nn )
    pl.plot(x,y,label = nlabel)
    pl.ioff()
    pl.legend()
    pl.draw()


# Load wing configuration file and create "wing" instance
#
# -----------------------------------------------
# sourceFile  - source csv file created by following structure
# analyzeStep - analyze slice steps スパン方向の分割数
# -----------------------------------------------
#
class wing(object):
    def __init__(self, sourceFile, halfStep):
        self._sourceFile = sourceFile
        self.halfStep = halfStep
        data = readcsv(self._sourceFile)
        self.surface = data[5][0]
        self.aspect = data[5][1]
        self.dihedral = data[5][2]
        self.XFOILdirectory = str(data[5][3])
        self.shapeData = data[9:]

    # --- >> calc the chord array according to slices --
        #スパン長の計算
        span = np.sqrt(self.aspect * self.surface)
        self.span = span

        #ルートコード長crの計算
        bunbo = 0.
        for i in range(0,len(self.shapeData)-1,1):
            bunbo += (self.shapeData[i][1]/100. + self.shapeData[i+1][1]/100.) * (self.shapeData[i+1][0]/100. - self.shapeData[i][0]/100.)
        bunbo = bunbo * span / 2.
        cr = self.surface / bunbo
        self.cr = cr


        #平面形のラムダとスパン位置のリスト作成
        spanlambda = [self.shapeData[i][1]/100. for i in range(len(self.shapeData))]
        spanratio = [self.shapeData[i][0]/100. for i in range(len(self.shapeData))]
        self.spanlambda = spanlambda

        #スパン位置
        y = [(self.span / 2.0) *np.cos((i + 1) * (np.pi / 2.0) / (self.halfStep)) for i in range(self.halfStep)]

        #コード長の配列 cosθ基準
        chordArray2 = []
        for yy in y:
            for i in range(len(spanlambda)-1):
                if spanratio[i]*self.span/2.0 <= yy and yy < spanratio[i + 1]*self.span/2.0:
                    chordArray2.append(self.calc_chord(spanlambda[i],spanlambda[i + 1],spanratio[i]*self.span/2.0,spanratio[i + 1]*self.span/2.0,cr,yy))
        self.yy = y
        self.chordArray2 = np.array(chordArray2)

        figx = cr * (1.0 - np.array(spanlambda))
        figy = self.span / 2.0 * np.array(spanratio)
        figy = list(figy)
        figy1 = figy[:]
        figy.reverse()
        figy2 = figy
        figyy = figy1 + figy2 + [figy2[len(figy2)-1]]
        figx = list(figx)
        for i in range(len(figy2)):
            figx.append(cr)
        figx.append(0)
        figxx = figx

        self.figxx = figxx
        self.figyy = figyy



    #コード長を求めるメソッド
    #lambda1:一つ前のテーパ比,lambda2:1つ後のテーパ比,y1:一つ前のスパン,y2:1つ後のスパン
    #Cr:ルートコード長、yy:求めるスパン長
    def calc_chord(self,lambda1,lambda2,y1,y2,Cr,yy):
        return lambda1 * Cr -(yy - y1) * (lambda1 - lambda2) / (y2 - y1) * Cr


    # Analyzes the wing object
    # -----------------------------------------------
    # velocity   - airspeed
    # temperature - temperature
    # angle      - angle of flight
    # -----------------------------------------------
    #
    #
    def calc_reynolds(self, velocity, temperature):
    # ----------- >> calc Reynolds array ------------------
        self.temperature = temperature
        self.velocity = velocity
        kine_vis = 1.34 * 10 ** - 5. + 9.31477 * 10 ** - 8. * self.temperature
        self.Re = np.array(self.chordArray2) * self.velocity / kine_vis
        self.airDensity = 1.28912 - 0.004122391 * self.temperature
        return self.Re
    # ----------- calc Reynolds array << ------------------

    #揚力傾斜をRe数ごと(スパン方向ごと)に計算
    def calc_liftSlopeArray(self):
        from scipy import stats
        datas = [self.calc_Interpolate(i) for i in testWing.Re/10**6.]

        liftSlopeArray = []
        for data in datas:
            start_angle = -3 #deg
            end_angle = 4 #deg

            slope, intercept, r_value, p_value, std_err = stats.linregress(np.radians(data.transpose()[0][start_angle+10:end_angle+10]),data.transpose()[1][start_angle+10:end_angle+10])
            liftSlopeArray.append(slope)
        self.liftSlopeArray = liftSlopeArray

    #ゼロ揚力角を計算
    def calc_zeroLiftAngle(self,data):
        from scipy import stats

        #揚力傾斜を出すのに使う迎角範囲
        start_angle = 0 #deg
        end_angle = 5 #deg

        slope, intercept, r_value, p_value, std_err = stats.linregress(np.radians(data.transpose()[0][start_angle+10:end_angle+10]),data.transpose()[1][start_angle+10:end_angle+10])
        self.zeroLiftAngle = - data[10][1] / slope

        return  self.zeroLiftAngle

    #ゼロ揚力角の配列の計算
    def calc_zeroliftangleArray(self):
        datas = [self.calc_Interpolate(i) for i in testWing.Re/10**6.]

        zeroliftangleArray = []
        for data in datas:
            zeroliftangleArray.append(self.calc_zeroLiftAngle(data))
        self.zeroliftangleArray = zeroliftangleArray

    def calc_Interpolate(self, Reynolds):
        from scipy import stats
        rey1 = round(Reynolds,1)
        rey2 = round(Reynolds,2)

        #レイノルズ数の小数点第2桁が0のとき,つまり内挿しなくていいとき 0.80とか
        if rey1 == rey2:
            txtFile = str(rey1)
            if len(txtFile)==1:
                txtFile+='.'
            for i in range(4-len(txtFile)):
                txtFile = txtFile+'0'

            self.XFOILfile = '/'+txtFile+'.txt'
            data = readdata(self.XFOILdirectory+self.XFOILfile)
        #内挿すべきとき たとえば0.84
        else:
            txtFile = str(rey1-0.1)
            if len(txtFile)==1:
                txtFile+='.'
            for i in range(4-len(txtFile)):
                txtFile = txtFile+'0'
            self.XFOILfile = '/'+txtFile+'.txt'
            data1 = readdata(self.XFOILdirectory+self.XFOILfile)

            txtFile = str(rey1)
            if len(txtFile)==1:
                txtFile+='.'
            for i in range(4-len(txtFile)):
                txtFile = txtFile+'0'
            self.XFOILfile = '/'+txtFile+'.txt'
            data2 = readdata(self.XFOILdirectory+self.XFOILfile)

            data = (data2-data1)*(rey2-rey1)/(float(str(rey1 + 0.1))-rey1)+data1

        return data

    #スパン方向のCD0の計算
    def calc_CD0Array(self):
        from scipy.interpolate import interp1d
        datas = [self.calc_Interpolate(i) for i in testWing.Re/10**6.]
        localangle = [self.angle - i for i in np.degrees(self.inducedAoa)]
        self.localangle = localangle #吹き下ろしを弾いた後の迎角配列
        cd0Array = []
        for i in range(len(self.Re)):
            #datas[i].transpose() #[0]と[2]でinterpolateする。
            linear_interp = interp1d(datas[i].transpose()[0], datas[i].transpose()[2])
            cd0Array.append(float(linear_interp(localangle[i])))
        self.cd0Array = cd0Array

    #Calculate center of pressure
    def calc_xcp(self):
        from scipy.interpolate import interp1d
        datas = [self.calc_Interpolate(i) for i in testWing.Re/10**6.]

        xcpArray = []
        for i in range(len(self.Re)):
            linear_interp = interp1d(datas[i].transpose()[0], datas[i].transpose()[9])
            xcpArray.append(float(linear_interp(self.localangle[i])))

        self.xcpArray = xcpArray
        self.chordcpArray = xcpArray * self.chordArray2
##        print self.chordcpArray,xcpArray,self.chordArray2
##        pl.plot(self.yy,self.chordArray2)
##        pl.plot(self.yy,self.chordcpArray)
##        pl.show()




    #吹き下ろしの計算
    #航空力学の基礎第2版 p.141 式3.97より
    def calc_downwash(self,thetas,An):
        dwArray = []
        for theta in thetas:
            dw = sum([(2*i+1)*An[i] * np.sin((2*i+1)*theta) / np.sin(theta) for i in range(len(An))]) * self.velocity
            dwArray.append(dw)
        self.dwArray = dwArray

    #ラジアンで出てくる
    def calc_inducedAoa(self):
        inducedAoa = np.array(self.dwArray) / self.velocity
        self.inducedAoa = inducedAoa

    # --------------- calc CD << ------------------


    # --------------------
    def calc_CL_Cdi_CD(self, angle, oddOReven = 1):
        self.angle = angle
        self.oddOReven = oddOReven
        #航空力学の基礎第2版 p.142 式3.99の下の式より
        #slopeはRe数ごとに与えることにした

        # μの計算。
        # self.liftSlopeArray[i] -> 5.5 で航空力学の基礎第2版 p.147の計算になる
        u = [self.liftSlopeArray[i] * self.chordArray2[i] / 4.0 / self.span for i in range(len(self.chordArray2))]




        #θの設定、θ[0]はpi/n, θ[1]は2pi/n, θ[2]は3pi/n・・・θ[ラスト]はpi/2
        thetas = [float(i)/(self.halfStep) * np.pi / 2.0 for i in range(1,self.halfStep+1)]

        #行列を作る計算
        lmatrix = []
        rmatrix = []
        i = 0
        for theta in thetas:
            tmp = []
            for n in range(1, self.halfStep * 2, oddOReven+1):

                tmp.append((n * u[i] + np.sin(theta)) * np.sin(n*theta))
            righthand = u[i] * np.sin(theta)
            lmatrix.append(tmp / righthand)

            #これを入れると航空力学の基礎p.147の連立方程式が再現できる
            #print tmp / righthand


            # 絶対迎角
            # absoluteAlpha = 1.0で航空力学の基礎第2版 p.147の計算になる
            absoluteAlpha = np.radians(self.angle) - self.zeroliftangleArray[i]
            #absoluteAlpha = 1.0
            rmatrix.append(absoluteAlpha)

            i+=1

        #連立方程式を行列を使って解く
        An = solve(np.array(lmatrix), np.array(rmatrix))
        #これをいれると航空力学の基礎p.147のAnの値がでる



        # calc CL
        self.CL = np.pi*self.aspect*An[0]

        # calc Cdi
        sigma = 0


        #航空力学の基礎第2版 p.147 式3.122の下の式より3からはじめる

        j = 3
        for i in range(self.oddOReven, self.halfStep):
            sigma += j * An[i] ** 2.0 / An[0] ** 2.0
            j += 2

        self.Cdi = (1.0 + sigma)*self.CL**2.0/np.pi/self.aspect




        #donw washと誘導迎角の計算
        self.calc_downwash(thetas,An)
        self.calc_inducedAoa()
        #new angleは吹き下ろしを考慮した迎角
        newangle = self.angle - np.degrees(self.inducedAoa)

        self.calc_CD0Array()
        #CD0の計算
        #calc CD2
        deltaD = []
        for i in range(len(self.chordArray2)):
            if i == 0:
                deltaD.append((self.cr * self.spanlambda[len(self.spanlambda)-1] + self.chordArray2[0]) * (self.span/2.0 - self.yy[i]) * 0.5 * self.cd0Array[0])
            else:
                deltaD.append((self.chordArray2[i-1] + self.chordArray2[i]) * (self.yy[i-1] - self.yy[i]) * 0.5 * (self.cd0Array[i-1] + self.cd0Array[i])/2.0)
        D2 = 0.5 * self.airDensity * self.velocity ** 2.0 * sum(deltaD)
        dCD = D2 / (0.5 * self.airDensity * self.velocity ** 2.0 * self.surface / 2.0)

        #風圧中心の計算
        self.calc_xcp()




        #スパン方向の揚力係数・循環・揚力計算
        circDist = []
        clDist = []
        j = 0
        for theta in thetas:
            summation = sum([An[i] * np.sin((2*i + 1) * theta) for i in range(0,self.halfStep)])

            #循環の計算
            circ = 2.0 * self.span * self.velocity * summation
            circDist.append(circ)

            #局所揚力係数の計算
            cllocal = 4.0 * self.span / self.chordArray2[j] * summation
            clDist.append(cllocal)
            j += 1

        self.circDist = circDist
        self.clDist = clDist


        dL = 0.5 * self.airDensity * self.velocity **2.0 * self.chordArray2 * clDist

        self.dL = dL





        #吹き下ろしの計算
        #print "---dw---",self.dwArray
        #誘導抵抗以外の抵抗：CD0
        self.CD0 = dCD
        self.CD = dCD + self.Cdi
        return self.CL, self.Cdi, self.CD

    #揚力の計算：単位はNで出る

    def calc_L(self):
        self.L = 0.5*self.airDensity*self.velocity**2.0*self.surface*self.CL*np.cos(np.radians(self.dihedral))

    #抵抗の計算：単位はNで出る
    def calc_D(self):
        self.D = 0.5*self.airDensity*self.velocity**2.0*self.surface*self.CD

    #ワット数の計算：単位はｗ
    def calc_W(self):
        self.W = self.D * self.velocity



    def calc_XFOIL(self):
        import os
        import time
        pwd = os.getcwd()
        pwd = pwd+'\\xfoil6.96\\bin'
        os.chdir(pwd)
        cmd = 'xfoil.exe'

        print 'done.'
        time.sleep(2)

    def calc_all(self, angle, Reynolds):
        self.calc_liftSlope(Reynolds)
        self.calc_zeroLiftAngle()
        self.calc_CL_Cdi_CD(angle)

    #翼面積、速度、重量が与えられたときのCLを計算するための関数
    def solve_CL(self,angle):
        testWing.calc_reynolds(self.velocity, self.temperature)
        testWing.calc_liftSlopeArray()
        testWing.calc_zeroliftangleArray()
        testWing.calc_CL_Cdi_CD(angle)

        Cw = self.weight*9.81 / (0.5 * self.airDensity * self.velocity ** 2.0 *self.surface)
        print Cw,self.CL
        return Cw - self.CL * np.cos(np.radians(self.dihedral))

    def calc_weight(self,weight):
        self.weight = weight

    def calc_withconstWeight(self):
        self.calc_weight(100)
        from scipy import optimize
        optimize.brenth(self.solve_CL,-10,10)
        print "CL = %0.3f" % self.CL
        print "CD0 = %0.4f" % self.CD0
        print "CDi = %0.4f" % self.Cdi
        print "CD = %0.4f" % self.CD
        self.calc_L()
        self.calc_D()
        self.calc_W()
        L = self.L/9.8
        print "Lift = %0.3f[kgf]" % L
        print "WingDrag = %0.3f[N]" % self.D
        print "WingPower = %0.3f[W]" % self.W
        print "---"

    # --------------- calc parasite CD << ------------------
    # --------------------
    # --------------------
    #
    #
class body(object):
    def __init__(self,velocity,temperature):
        self.temperature = temperature
        self.velocity = velocity
        kine_vis = 1.34 * 10 ** - 5. + 9.31477 * 10 ** - 8. * self.temperature
        self.airDensity = 1.28912 - 0.004122391 * self.temperature
        self.dynpres = 0.5 * self.airDensity * self.velocity ** 2.0

    def fairdragcalc(self,fairArea):
        CDfair = 0.1
        self.fairringDrag = CDfair * fairArea * self.dynpres
        self.fairringPower = self.fairringDrag * self.velocity

    def framedragcalc(self,framearea):
        CDframe = 0.1
        self.frameDrag = CDframe * framearea * self.dynpres
        self.framePower = self.frameDrag * self.velocity


class tail(object):
    def __init__(self,velocity,temperature):
        self.temperature = temperature
        self.velocity = velocity
        kine_vis = 1.34 * 10 ** - 5. + 9.31477 * 10 ** - 8. * self.temperature
        self.airDensity = 1.28912 - 0.004122391 * self.temperature
        self.dynpres = 0.5 * self.airDensity * self.velocity ** 2.0

    def calc_htaildrag(self,htailArea):
        CDhtail = 0.008
        self.htailDrag = CDhtail * htailArea * self.dynpres
        self.htailPower = self.htailDrag * self.velocity

    def calc_vtaildrag(self,vtailArea):
        CDvtail = 0.008
        self.vtailDrag = CDvtail * vtailArea * self.dynpres
        self.vtailPower = self.vtailDrag * self.velocity



if __name__ == '__main__':
    # 4分割で航空力学の基礎第2版 p.147の計算になる
    # wing('kokurikgaku_p.147.csv',4)
    testWing = wing('testplane.csv',40)
    testWing.calc_reynolds(9, 30)

##    testWing.calc_withconstWeight()

    testWing.calc_liftSlopeArray()
    testWing.calc_zeroliftangleArray()
    testWing.calc_CL_Cdi_CD(3)

    print "CL = %0.3f" % testWing.CL
    print "CD0 = %0.4f" % testWing.CD0
    print "CDi = %0.4f" % testWing.Cdi
    print "CD = %0.4f" % testWing.CD
    testWing.calc_L()
    testWing.calc_D()
    testWing.calc_W()
    L = testWing.L/9.8
    print "Lift = %0.3f[kgf]" % L
    print "WingDrag = %0.3f[N]" % testWing.D
    print "WingPower = %0.3f[W]" % testWing.W

    #print testWing.dwArray

    testBody = body(8,30)
    testBody.fairdragcalc(1.26)
    testBody.framedragcalc(0.0078)
    print "Fair Power = %0.3f[W]" % testBody.fairringPower
    print "Frame Power = %0.3f[W]" % testBody.framePower


    testTail = tail(8,30)
    testTail.calc_htaildrag(2.0)
    testTail.calc_vtaildrag(1.5)
    print "htail Power = %0.3f[W]" % testTail.htailPower
    print "vtail Power = %0.3f[W]" % testTail.vtailPower


    RequiredPower = testBody.framePower + testBody.fairringPower + testWing.W + testTail.htailPower + testTail.vtailPower
    print "Required Power = %0.3f[W]" % RequiredPower



